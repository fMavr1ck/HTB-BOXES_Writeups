The command print(globals()) in Python is used to display all global variables, functions, and objects available in the current scope.

What does globals() do?
It returns a dictionary (dict) containing all globally accessible names (variables, functions, classes, etc.) in the current module or interactive session.

Useful for debugging, reverse engineering, or exploiting restricted Python environments (like in your HTB machine).

Why is this useful in Hack The Box?
In a restricted Python sandbox (like the one you found on port 5000), globals() helps you:

List all available variables/functions the app is using.

Find hidden secrets (e.g., hardcoded credentials in global variables).

Identify dangerous functions (e.g., os, subprocess, eval) that might be usable for escaping the sandbox.

Example Output
If you run print(globals()) in a Flask web app, you might see:

python
{
  '__name__': '__main__',
  '__file__': 'app.py',
  'app': <Flask 'app'>,  # The Flask application object
  'secret_key': 's3cr3t_k3y_123',  # Possible hardcoded secret
  'db': <SQLite3 database object>,  # Database connection
  'os': <module 'os' from '...'>,  # If 'os' module is imported
  ...
}
How Attackers Use globals() in HTB
Find Sensitive Data

If the app has hardcoded credentials (DB_PASSWORD, SECRET_KEY), they might appear in globals().

Example:

python
print(globals()['SECRET_KEY'])
Check for Dangerous Functions

If os or subprocess is imported, you might escape the sandbox:

python
globals()['os'].system('whoami')  # Execute system commands
Understand the Appâ€™s Structure

Helps in reverse engineering (e.g., finding Flask routes, configs).

